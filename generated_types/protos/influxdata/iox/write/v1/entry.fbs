namespace influxdata.iox.write.v1;

// Every modification to a database is represented as an entry. These can be forwarded
// on to other IOx servers or can be wrapped with a logical clock value and writer id
// for ordering in a buffer or to subscribers. An Entry is what gets sent from the
// routing layer to the write buffer layer. The write buffer layer uses seqenced entries
// to replicate to its peers and to send to downstream subscribers.
//
// Take the example of sharding, where an IOx server is configured to split an
// incoming write into shards and send the write onto other servers. The batch of line protocol
// written in a request will be split up so that each shard with data will have a
// single Entry that will be sent to it. If the server that is doing the
// sharding is not generating partition keys, the key in partition write won't be
// present. It can be generated downstream. Although it's better to have the sharding
// layer generate the partition keys while it's at the job of parsing and validating
// the line protocol. This will save the downstream stateful layers from doing
// extra work.
//
// Even though this entry type has multiple fields (writes, deletes, others), they
// are mutually exclusive. That is an Entry will only ever have one of those fields.
// So you won't have an entry that has writes and deletes.
table Entry {
  // A collection of partition writes. A given partition will have at most one
  // write in this collection.
  writes: [PartitionWrite];
  // A collection of deletes. Each delete targets a single table, with each table
  // having no more than one delete. Deletes can span partitions because they
  // only have a predicate and do not target any specific partition.
  deletes: [Delete];
}

// A delete from a single table with a predicate. Deletes can span partitions since
// they're concerned with data that has already been written. Partitioning is a way
// to split up writes as they land.
table Delete {
  table_name: string;
  predicate: string;
}

// A write to a  partition. If the IOx server creating this PartitionWrite has
// no rules for generating partition keys, the key will be null, representing
// the empty string.
table PartitionWrite {
  key: string;
  table_batches: [TableWriteBatch];
}

// A collection of rows to write to a single table.
table TableWriteBatch {
  name: string;
  columns: [Column];
}

// A single column
table Column {
  // The name of the column
  name: string;

  // The semantic meaning of the column.
  column_type: ColumnType; // is "type" allowed as a field name or not?
  
  // The values within the column
  //
  // Thoughts! If you know that all of the values in a column are not NULL, which
  // I assume is the case for columns originating from line protocol (unless 
  // some pivoting has already happened?), then you can probably improve memory
  // and performance here by having variants for `ColumnValue` that are simply
  // vectors of scalars... So here instead of `[ColumnValue]` you would have a
  // union and some of the variants of the union would be `ColumnValue` (for e.g.,
  // columns with NULL in) and some of the variants would just be e.g., `[int64]`
  // for columns with no null values in.
  values: [ColumnValue];
}

// The semantic meaning of a column of data.
enum ColumnType : byte { Tag = 1, Field, Timestamp, Other}

// Possible logical types for a column. 
union ColumnValue {
  I64Value,
  U64Value,
  F64Value,
  BoolValue,
  BytesValues, // do you want this right now?
  StringValue
}

table I64Value {
  value: int64;
}

table U64Value {
  value: uint64;
}

table F64Value {
  value: float64;
}

table BoolValue {
  value: bool;
}

table StringValue {
  value: string;
}

// The following definitions are for the write buffer and for downstream subscribers to
// the buffer.

// Segment is a collection of Entries. It is the payload of a Write Buffer
// segment file. Because Write Buffer servers can replicate data with peers,
// entries in the collection may come from different writer ids. Entries within
// a segment should be ordered by ascending order by the clock value then writer id.
table Segment {
  // the segment number
  id: uint64;
  // the writer id of the server that persisted this segment
  writer_id: uint32;
  // this is the clock value that the writer has verified with its peers that
  // entries are ordered and consistent up to. If the writer has no peers this
  // value will just be the clock value for the last sequenced entry in this segment.
  // This value could be lower than the first clock value in the segment if a
  // consistency check has not occured since this segment was started. Or, if
  // a consistency check has occured in a segment following this one, but before
  // this segment has been persisted, the clock value could be higher than the last
  // entry in the segment. This latter condition indicates that all entries in the
  // segment are properly ordered and consistent with other write buffer peers.
  consistency_high_water_clock: uint64;
  // the raw entry data along with their sequence numbers
  entries: [SequencedEntry];
}

// SequencedEntry are what get inserted into a Write Buffer. These are
// what Write Buffer servers replicate to their peers and what go out to
// downstream subscribers of the Buffer. The clock values can be used to order
// the entries from a Buffer server. They are guaranteed to never go backwards.
table SequencedEntry {
  clock_value: uint64;
  writer_id: uint32;
  entry: Entry;
}
